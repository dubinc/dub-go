// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/dubinc/dub-go/internal/utils"
	"github.com/dubinc/dub-go/models/components"
)

type QueryParamTagIdsType string

const (
	QueryParamTagIdsTypeStr        QueryParamTagIdsType = "str"
	QueryParamTagIdsTypeArrayOfStr QueryParamTagIdsType = "arrayOfStr"
)

// QueryParamTagIds - The tag IDs to filter the links by.
type QueryParamTagIds struct {
	Str        *string
	ArrayOfStr []string

	Type QueryParamTagIdsType
}

func CreateQueryParamTagIdsStr(str string) QueryParamTagIds {
	typ := QueryParamTagIdsTypeStr

	return QueryParamTagIds{
		Str:  &str,
		Type: typ,
	}
}

func CreateQueryParamTagIdsArrayOfStr(arrayOfStr []string) QueryParamTagIds {
	typ := QueryParamTagIdsTypeArrayOfStr

	return QueryParamTagIds{
		ArrayOfStr: arrayOfStr,
		Type:       typ,
	}
}

func (u *QueryParamTagIds) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = QueryParamTagIdsTypeStr
		return nil
	}

	var arrayOfStr []string = []string{}
	if err := utils.UnmarshalJSON(data, &arrayOfStr, "", true, true); err == nil {
		u.ArrayOfStr = arrayOfStr
		u.Type = QueryParamTagIdsTypeArrayOfStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for QueryParamTagIds", string(data))
}

func (u QueryParamTagIds) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.ArrayOfStr != nil {
		return utils.MarshalJSON(u.ArrayOfStr, "", true)
	}

	return nil, errors.New("could not marshal union type QueryParamTagIds: all fields are null")
}

type QueryParamTagNamesType string

const (
	QueryParamTagNamesTypeStr        QueryParamTagNamesType = "str"
	QueryParamTagNamesTypeArrayOfStr QueryParamTagNamesType = "arrayOfStr"
)

// QueryParamTagNames - The unique name of the tags assigned to the short link (case insensitive).
type QueryParamTagNames struct {
	Str        *string
	ArrayOfStr []string

	Type QueryParamTagNamesType
}

func CreateQueryParamTagNamesStr(str string) QueryParamTagNames {
	typ := QueryParamTagNamesTypeStr

	return QueryParamTagNames{
		Str:  &str,
		Type: typ,
	}
}

func CreateQueryParamTagNamesArrayOfStr(arrayOfStr []string) QueryParamTagNames {
	typ := QueryParamTagNamesTypeArrayOfStr

	return QueryParamTagNames{
		ArrayOfStr: arrayOfStr,
		Type:       typ,
	}
}

func (u *QueryParamTagNames) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = QueryParamTagNamesTypeStr
		return nil
	}

	var arrayOfStr []string = []string{}
	if err := utils.UnmarshalJSON(data, &arrayOfStr, "", true, true); err == nil {
		u.ArrayOfStr = arrayOfStr
		u.Type = QueryParamTagNamesTypeArrayOfStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for QueryParamTagNames", string(data))
}

func (u QueryParamTagNames) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.ArrayOfStr != nil {
		return utils.MarshalJSON(u.ArrayOfStr, "", true)
	}

	return nil, errors.New("could not marshal union type QueryParamTagNames: all fields are null")
}

// Sort - The field to sort the links by. The default is `createdAt`, and sort order is always descending.
type Sort string

const (
	SortCreatedAt   Sort = "createdAt"
	SortClicks      Sort = "clicks"
	SortLastClicked Sort = "lastClicked"
)

func (e Sort) ToPointer() *Sort {
	return &e
}
func (e *Sort) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "createdAt":
		fallthrough
	case "clicks":
		fallthrough
	case "lastClicked":
		*e = Sort(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Sort: %v", v)
	}
}

type GetLinksRequest struct {
	// The domain to filter the links by. E.g. `ac.me`. If not provided, all links for the workspace will be returned.
	Domain *string `queryParam:"style=form,explode=true,name=domain"`
	// The tag ID to filter the links by. This field is deprecated â€“ use `tagIds` instead.
	TagID *string `queryParam:"style=form,explode=true,name=tagId"`
	// The tag IDs to filter the links by.
	TagIds *QueryParamTagIds `queryParam:"style=form,explode=true,name=tagIds"`
	// The unique name of the tags assigned to the short link (case insensitive).
	TagNames *QueryParamTagNames `queryParam:"style=form,explode=true,name=tagNames"`
	// The search term to filter the links by. The search term will be matched against the short link slug and the destination url.
	Search *string `queryParam:"style=form,explode=true,name=search"`
	// The user ID to filter the links by.
	UserID *string `queryParam:"style=form,explode=true,name=userId"`
	// Whether to include archived links in the response. Defaults to `false` if not provided.
	ShowArchived *bool `default:"false" queryParam:"style=form,explode=true,name=showArchived"`
	// DEPRECATED. Filter for links that have at least one tag assigned to them.
	WithTags *bool `default:"false" queryParam:"style=form,explode=true,name=withTags"`
	// The field to sort the links by. The default is `createdAt`, and sort order is always descending.
	Sort *Sort `default:"createdAt" queryParam:"style=form,explode=true,name=sort"`
	// The page number for pagination.
	Page *float64 `default:"1" queryParam:"style=form,explode=true,name=page"`
	// The number of items per page.
	PageSize *float64 `default:"100" queryParam:"style=form,explode=true,name=pageSize"`
}

func (g GetLinksRequest) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetLinksRequest) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *GetLinksRequest) GetDomain() *string {
	if o == nil {
		return nil
	}
	return o.Domain
}

func (o *GetLinksRequest) GetTagID() *string {
	if o == nil {
		return nil
	}
	return o.TagID
}

func (o *GetLinksRequest) GetTagIds() *QueryParamTagIds {
	if o == nil {
		return nil
	}
	return o.TagIds
}

func (o *GetLinksRequest) GetTagNames() *QueryParamTagNames {
	if o == nil {
		return nil
	}
	return o.TagNames
}

func (o *GetLinksRequest) GetSearch() *string {
	if o == nil {
		return nil
	}
	return o.Search
}

func (o *GetLinksRequest) GetUserID() *string {
	if o == nil {
		return nil
	}
	return o.UserID
}

func (o *GetLinksRequest) GetShowArchived() *bool {
	if o == nil {
		return nil
	}
	return o.ShowArchived
}

func (o *GetLinksRequest) GetWithTags() *bool {
	if o == nil {
		return nil
	}
	return o.WithTags
}

func (o *GetLinksRequest) GetSort() *Sort {
	if o == nil {
		return nil
	}
	return o.Sort
}

func (o *GetLinksRequest) GetPage() *float64 {
	if o == nil {
		return nil
	}
	return o.Page
}

func (o *GetLinksRequest) GetPageSize() *float64 {
	if o == nil {
		return nil
	}
	return o.PageSize
}

type GetLinksResponse struct {
	Result []components.LinkSchema

	Next func() (*GetLinksResponse, error)
}

func (o *GetLinksResponse) GetResult() []components.LinkSchema {
	if o == nil {
		return []components.LinkSchema{}
	}
	return o.Result
}
